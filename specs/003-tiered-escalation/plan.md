# Implementation Plan: Multi-Tier Model Escalation

**Branch**: `003-tiered-escalation` | **Date**: 2026-02-17 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specs/003-tiered-escalation/spec.md`

## Summary

Add N-tier model escalation to `ma-loop run`. Users define an ordered JSON list of model tiers (local/free → mid → power). The system runs each tier's full iteration budget before escalating; failure history accumulates across tiers and is injected into each new tier's context so no tier starts cold. A persistent SQLite database records every iteration across all tiers for post-run analysis. Fully opt-in — zero change to existing behaviour when no tier config is present.

~350 lines of new code across 4 new source files + minor updates to `run.ts` and `ralph-loop.ts`.

---

## Technical Context

**Language/Version**: TypeScript 5.x (Node.js 20+)
**Primary Dependencies**:
- Existing: `zod` (config validation), `uuid` (run IDs), `commander` (CLI flags), `ollama` (local models)
- New: `better-sqlite3` + `@types/better-sqlite3` (audit database)
**Storage**: SQLite (best-effort append-only audit log at `.micro-agent/audit.db`)
**Testing**: vitest — existing 247-test suite extended with new unit + integration tests
**Target Platform**: Linux/macOS CLI
**Performance Goals**: Escalation handoff < 2 seconds (SC-002); per-tier overhead identical to existing simple/full paths
**Constraints**: Global budget (cost/time) shared across all tiers; SQLite writes never block run outcome; backward-compatible (FR-010, SC-006)
**Scale/Scope**: 4 new source files in `src/lifecycle/`; minor updates to `run.ts` and `ralph-loop.ts`

---

## Constitution Check

No constitution.md exists for this project. Applying common-sense gates from 002-simple-escalation precedent:

- ✅ One new external dependency (`better-sqlite3`) — justified by SQLite audit requirement (FR-008); best-in-class for sync CLI SQLite
- ✅ No new agent types — reuses ArtisanAgent, LibrarianAgent, CriticAgent unchanged
- ✅ Fresh context per iteration preserved (Ralph Loop gold standard)
- ✅ Budget controls respected across all tiers (global budget = hard cap)
- ✅ Backward compatible — zero change when no `tierConfigFile` configured (FR-010, SC-006)
- ✅ Existing 247 tests unaffected (new tests added, none modified)
- ✅ SQLite writes are best-effort — run outcome never blocked by DB failure
- ✅ Zod validation at startup — all tier config errors reported before any LLM calls (FR-012)

---

## Project Structure

### Documentation (this feature)

```text
specs/003-tiered-escalation/
├── plan.md              ← this file
├── spec.md              ← feature specification
├── research.md          ← Phase 0 decisions
├── data-model.md        ← entity definitions and SQLite schema
├── quickstart.md        ← user-facing guide
├── contracts/
│   ├── tier-config-schema.md   ← JSON tier config schema + examples
│   ├── sqlite-schema.md        ← SQLite DDL + example queries
│   └── cli-interface.md        ← CLI flags, function signatures, output formats
└── tasks.md             ← generated by /speckit.tasks (next step)
```

### Source Code Changes

```text
src/
├── lifecycle/                              # NEW DIRECTORY
│   ├── tier-config.ts                      # NEW: TierEscalationConfig Zod schema, loadTierConfig(), validateTierConfig()
│   ├── tier-engine.ts                      # NEW: runTier() — one tier's iteration loop
│   ├── tier-accumulator.ts                 # NEW: buildAccumulatedSummary(), withTierEscalationContext()
│   └── tier-db.ts                          # NEW: openAuditDatabase(), writeAttemptRecord(), writeRunMetadata()
├── cli/
│   └── commands/
│       └── run.ts                          # MODIFIED: detect tierConfig, delegate to TierEngine, updated report
└── ralph-loop.ts                           # MODIFIED: add --tier-config <path> CLI flag

tests/
├── unit/
│   └── lifecycle/
│       ├── simple-escalation.test.ts       # EXISTING (247 tests passing — untouched)
│       ├── tier-config.test.ts             # NEW: config loading, Zod schema, validation errors
│       ├── tier-accumulator.test.ts        # NEW: buildAccumulatedSummary(), withTierEscalationContext()
│       └── tier-db.test.ts                 # NEW: schema creation, write/read, best-effort error handling
└── integration/
    ├── escalation-flow.test.ts             # EXISTING (19 tests — untouched)
    └── tier-engine.test.ts                 # NEW: full tier engine flows, escalation handoff, SQLite writes
```

---

## Implementation Phases

### Wave 1: Config Layer (~1.5 hours)

1. Install `better-sqlite3` and `@types/better-sqlite3`
2. Create `src/lifecycle/tier-config.ts`:
   - `TierModelsSchema`, `TierConfigSchema`, `TierEscalationConfigSchema` (Zod)
   - `loadTierConfig(filePath: string): TierEscalationConfig` — reads JSON, validates, returns typed config
   - `validateTierConfig(config) → string[]` — returns all validation errors (fail-fast, FR-012)
3. Add `--tier-config <path>` flag to `ralph-loop.ts`
4. Unit tests: `tests/unit/lifecycle/tier-config.test.ts`

**Gate**: Config loads from JSON, Zod errors shown correctly, invalid model names caught at startup

---

### Wave 2: Audit Database (~1 hour)

1. Create `src/lifecycle/tier-db.ts`:
   - `openAuditDatabase(dbPath)` — opens or creates SQLite DB, runs DDL (idempotent)
   - `writeAttemptRecord(db, record)` — INSERT INTO tier_attempts; try/catch, warn on failure
   - `writeRunMetadata(db, metadata)` — INSERT/UPDATE run_metadata; try/catch, warn on failure
   - `closeAuditDatabase(db)` — closes connection
2. Unit tests: `tests/unit/lifecycle/tier-db.test.ts`
   - Schema creation is idempotent
   - Records written and readable
   - Failures caught and warned (not thrown)

**Gate**: SQLite file created at correct path; records inserted; DB errors don't crash the process

---

### Wave 3: Tier Accumulator (~1 hour)

1. Create `src/lifecycle/tier-accumulator.ts`:
   - `buildAccumulatedSummary(priorResults: TierRunResult[]): AccumulatedFailureSummary`
     - Concatenates each tier's summary with `=== TIER N FAILURES: <name> ===` headers
     - Caps at 4000 characters; truncates oldest tier history first
   - `withTierEscalationContext(context, summary): AgentContext`
     - Wraps existing `withEscalationContext()` from `agent-context.ts`
2. Unit tests: `tests/unit/lifecycle/tier-accumulator.test.ts`
   - Correct header format
   - 4000-char cap with truncation marker
   - Single tier vs multi-tier accumulation
   - Immutability (original context unchanged)

**Gate**: Accumulated summary format matches `contracts/cli-interface.md` escalation event format

---

### Wave 4: Tier Engine (~2 hours)

1. Create `src/lifecycle/tier-engine.ts`:
   - `runTier(tier, tierIndex, context, agents, testRunner, db, runId): Promise<TierRunResult>`
     - Runs the correct mode (`simple` or `full`) based on `tier.mode`
     - Simple mode: reuses `runSimpleIteration()` from `run.ts` (or extracts to shared function)
     - Full mode: reuses `runSingleIteration()` from `run.ts`
     - Writes `TierAttemptRecord` to DB after each iteration
     - Exits loop on success, budget exhaustion, or `maxIterations` reached
     - Returns `TierRunResult` with all records and exit reason
2. Update `src/cli/commands/run.ts`:
   - Detect `options.tierConfig` (or `config.tierConfigFile`)
   - If present: validate config → open DB → loop through tiers → close DB → final report
   - If absent: existing simple/full path unchanged
3. Integration tests: `tests/integration/tier-engine.test.ts`
   - Single tier success at iteration 1
   - Single tier exhausts all iterations → fails cleanly
   - 2-tier escalation: tier 1 fails, tier 2 succeeds
   - Budget exhaustion mid-tier: exits, remaining tiers skipped
   - Global budget prevents tier 3 from starting
   - SQLite records written for all iterations across tiers
   - Report format matches `contracts/cli-interface.md`

**Gate**: All three flow types (single-tier success, escalation, budget-stop) produce correct output

---

### Wave 5: Final Report & Polish (~45 min)

1. Update final report in `run.ts` to show tiered summary (contracts/cli-interface.md format):
   - Per-tier row: name, mode, iterations, cost, status
   - Total line: all tiers combined
   - Audit log path + run ID
   - Hint to query SQLite on full failure
2. Update startup banner to show tier plan
3. Warn if legacy flags (`--simple`, `--full`, `--no-escalate`) used alongside `--tier-config`

**Gate**: Output format matches contracts/cli-interface.md for all three report scenarios (success, full-fail, budget-stop)

---

### Wave 6: Tests Gate (~30 min)

1. Run full test suite; confirm ≥ 290 tests pass (247 existing + ~43 new)
2. Spot-check: existing 247 tests unchanged (no regressions)
3. Confirm `--tier-config` absent → zero behaviour change (FR-010, SC-006)

**Gate**: All tests green; regression count = 0

---

## Risk & Mitigations

| Risk | Likelihood | Mitigation |
|------|------------|-----------|
| `better-sqlite3` native binding fails on some Linux distros | Low | Pre-built binaries are available for all major distros via npm; documented in troubleshooting |
| Accumulated failure context exceeds 4000 chars with many tiers | Medium | Hard-cap at 4000 chars; truncate oldest tier first; most runs have 2-3 tiers max |
| Per-tier model override conflicts with AgentContext model field | Low | Pass model string directly to provider router; `AgentContext.model` is overridden per-tier |
| SQLite file path resolves wrong relative to working directory | Low | Resolve path relative to `options.workingDirectory` explicitly, same as other file paths |
| Users confuse tier `mode` with legacy `--simple`/`--full` flags | Low | Warning logged when both legacy flags and tier config are present; quickstart documents separation |

---

## Complexity Tracking

No constitution violations. No unjustified complexity.

| Addition | Why | Simpler Alternative Rejected Because |
|---------|-----|-------------------------------------|
| `better-sqlite3` dependency | FR-008 requires persistent audit log | In-memory (lost at process end), plain JSON (no queryability), or no log at all violate the spec requirement |
| 4 new source files in `src/lifecycle/` | Clean separation of tier-specific logic | Adding all tier logic to `run.ts` would make it 1000+ lines; feature isolation is easier to test and maintain |
