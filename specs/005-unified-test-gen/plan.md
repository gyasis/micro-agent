# Implementation Plan: Unified Test Generation for ma-loop

**Branch**: `005-unified-test-gen` | **Date**: 2026-02-22 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/005-unified-test-gen/spec.md`

## Summary

`ma-loop run <target>` has no test generation step — it fails silently when no test file exists.
This plan adds an auto-generation step that fires before the iteration loop: when `ma-loop run
src/math.ts` is invoked and no `math.test.ts` exists, Claude Sonnet generates one, writes it
to disk, and scopes the test command to that file only. Existing tests are never touched.
Users can opt out with `--no-generate` or `--test`.

## Technical Context

**Language/Version**: TypeScript 5.9.3 (Node.js 18+)
**Primary Dependencies**: `glob` v10 (already installed), `fs/promises` (built-in),
`ProviderRouter` (src/llm/provider-router.ts), `detectFramework` (src/parsers/framework-detector.ts)
**Storage**: Disk only — generates one `.test.{ext}` file per invocation
**Testing**: Vitest v1.6.1 (project standard)
**Target Platform**: Linux / macOS CLI (same as the rest of ma-loop)
**Performance Goals**: Generation completes in <30s (single LLM call); no impact on loop speed
**Constraints**: Zero new npm dependencies; must not break 273 existing tests; tsc clean
**Scale/Scope**: 1 new module, 2 modified files, 1 new test file

## Constitution Check

*No constitution.md found in .specify/memory/ — applying project standards from CLAUDE.md:*

- ✅ No new npm dependencies introduced
- ✅ Pure function module (no class, no side effects in exports)
- ✅ Dynamic import matches established pattern (runSimpleIteration)
- ✅ No test logic manipulation — tests must pass on real behavior
- ✅ Uses ProviderRouter (consistent with rest of stack, not legacy ini config)
- ✅ All 273 existing tests must continue to pass

## Project Structure

### Documentation (this feature)

```text
specs/005-unified-test-gen/
├── plan.md                    # This file
├── spec.md                    # Feature specification (5 user stories)
├── research.md                # Phase 0: 8 decisions resolved
├── data-model.md              # Phase 1: entities + state transitions
├── quickstart.md              # Phase 1: smoke test scripts
├── contracts/
│   └── test-generator-api.md  # Phase 1: full API contract
└── tasks.md                   # Phase 2: generated by /speckit.tasks
```

### Source Code

```text
src/helpers/
├── test-generator.ts          # NEW — core generation module

src/cli/
├── ralph-loop.ts              # MODIFY — add --no-generate flag
└── commands/
    └── run.ts                 # MODIFY — insert generation step + RunOptions.generate field

tests/unit/helpers/
└── test-generator.test.ts     # NEW — unit tests for all functions
```

## Implementation Details

### New File: `src/helpers/test-generator.ts`

Pure-function module. No class. All exports are async functions or interfaces.

**Exported surface**:
```typescript
export interface TestGeneratorOptions { ... }
export interface TestGeneratorResult { ... }
export async function findExistingTests(targetFile, workingDir): Promise<string | null>
export async function generateTestFile(options: TestGeneratorOptions): Promise<TestGeneratorResult>
```

**Key internal flow inside `generateTestFile()`**:
1. Call `resolveTestFilePath(targetFile, framework)` → get output path
2. If null (Rust) → throw `new Error('Rust targets not supported')` (caller handles)
3. Read source file: `await fs.readFile(path.resolve(workingDir, targetFile), 'utf8')`
4. Call `gatherExampleTests(workingDir)` → up to 2 example strings
5. Read `package.json` if exists: `await fs.readFile(path.join(workingDir, 'package.json'), 'utf8').catch(() => '')`
6. Build messages: `buildGenerationMessages(targetFile, src, objective, testFilePath, examples, pkgJson)`
7. `const router = new ProviderRouter()`
8. `const response = await router.complete({ provider: 'anthropic', model, messages, temperature: 0.7, maxTokens: 4096 })`
9. `const code = extractCodeBlock(response.content)`
10. `await fs.mkdir(path.dirname(testFilePath), { recursive: true })`
11. `await fs.writeFile(testFilePath, code, 'utf8')`
12. Return `{ testFilePath, testCommand: buildTestCommand(testFilePath, framework), generatedByModel: response.model }`

### Modification: `src/cli/commands/run.ts`

**1. Add to `RunOptions` interface** (after `tierConfig?: string`):
```typescript
generate?: boolean;   // Commander sets false when --no-generate is passed
```

**2. Insert generation block** after line ~111 (`prepareRunParameters` call), BEFORE
`initializeInfrastructure` call:
```typescript
// Step 2.5: Test Generation
if (params.targetFile && options.generate !== false && !options.test) {
  const { findExistingTests, generateTestFile } = await import('../../helpers/test-generator');
  const existingTest = await findExistingTests(params.targetFile, params.workingDirectory);
  if (!existingTest) {
    const ext = path.extname(params.targetFile);
    if (ext !== '.rs') {
      logger.info(`No tests found for ${params.targetFile} — generating with Sonnet...`);
      try {
        const genResult = await generateTestFile({
          targetFile: params.targetFile,
          objective: params.objective,
          workingDir: params.workingDirectory,
          framework: params.testFramework,
          model: options.artisan || 'claude-sonnet-4-20250514',
          verbose: options.verbose,
        });
        logger.info(`Generated: ${genResult.testFilePath}`);
        params.testCommand = genResult.testCommand;
      } catch (genErr) {
        logger.warn(`Test generation failed: ${String(genErr)} — continuing without generated test`);
      }
    } else {
      logger.info(`Skipping test generation for Rust (.rs) — use inline #[test] blocks`);
    }
  } else {
    logger.info(`Using existing tests: ${existingTest}`);
  }
}
```

### Modification: `src/cli/ralph-loop.ts`

**1. Update command description** (line 35):
```typescript
.description('Run Ralph Loop iterations for a file or objective (auto-generates tests if none exist)')
```

**2. Add `--no-generate` option** after existing `--tier-config` option (line ~84):
```typescript
.option(
  '--no-generate',
  'Skip automatic test file generation when no test file exists',
)
```

### New File: `tests/unit/helpers/test-generator.test.ts`

Test groups covering all internal + exported functions:
- `resolveTestFilePath` — 6 cases (.ts, .js, .py, .rs→null, .rb, nested path)
- `extractCodeBlock` — 4 cases (ts fence, py fence, no fence, fence without lang)
- `buildTestCommand` — 6 cases (vitest, jest, pytest, rspec, custom/fallback, cargo/fallback)
- `findExistingTests` — 5 cases (no test, .test.ts, .spec.ts, .rs always null, test_foo.py)
- `generateTestFile` — 9 cases (router called, default model, model override, writes file,
  vitest command, pytest command, Rust throws, 2 examples included, no examples fallback)

All mocks: ProviderRouter, fs/promises, glob, path resolution.

## Verification Checkpoints

| Gate                    | Command                                  | Expected         |
|-------------------------|------------------------------------------|------------------|
| Unit tests (new)        | `npm test -- --testPathPattern="test-generator"` | All pass |
| Full regression         | `npm test`                               | 273+ pass        |
| TypeScript clean        | `npx tsc --noEmit`                       | 0 errors         |
| Smoke test (generation) | See quickstart.md Test 1                 | test file created|
| Smoke test (passthrough)| See quickstart.md Test 2                 | no new file      |
| Smoke test (--no-gen)   | See quickstart.md Test 3                 | no file created  |
