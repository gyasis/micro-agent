/**
 * Mutation Testing Integration
 *
 * Integrates with Stryker mutation testing framework.
 * Introduces small changes (mutations) to code and verifies tests catch them.
 *
 * @module agents/chaos/mutation-testing
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { promises as fs } from 'fs';
import path from 'path';

const execAsync = promisify(exec);

export interface MutationResult {
  mutationScore: number;
  killed: number;
  survived: number;
  timeout: number;
  noCoverage: number;
  total: number;
  mutations: Mutation[];
}

export interface Mutation {
  id: string;
  mutatorName: string;
  location: {
    file: string;
    start: { line: number; column: number };
    end: { line: number; column: number };
  };
  replacement: string;
  status: 'Killed' | 'Survived' | 'Timeout' | 'NoCoverage';
  killedBy?: string[];
}

export interface MutationConfig {
  mutators?: string[];
  testRunner?: string;
  coverageAnalysis?: 'perTest' | 'all' | 'off';
  timeout?: number;
}

const DEFAULT_CONFIG: Required<MutationConfig> = {
  mutators: [
    'ArithmeticOperator',
    'BlockStatement',
    'BooleanLiteral',
    'ConditionalExpression',
    'EqualityOperator',
    'LogicalOperator',
    'StringLiteral',
    'UnaryOperator',
  ],
  testRunner: 'vitest',
  coverageAnalysis: 'perTest',
  timeout: 300000, // 5 minutes
};

/**
 * Mutation testing runner
 */
export class MutationTesting {
  private config: Required<MutationConfig>;

  constructor(config: MutationConfig = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Run mutation testing on file
   */
  async runMutationTests(
    filePath: string,
    testPattern?: string,
  ): Promise<MutationResult> {
    try {
      // Create Stryker config
      await this.createStrykerConfig(filePath, testPattern);

      // Run Stryker
      const { stdout, stderr } = await execAsync('npx stryker run', {
        timeout: this.config.timeout,
      });

      // Parse results
      return await this.parseStrykerResults();
    } catch (error) {
      throw new Error(`Mutation testing failed: ${error}`);
    }
  }

  /**
   * Create Stryker configuration
   */
  private async createStrykerConfig(
    filePath: string,
    testPattern?: string,
  ): Promise<void> {
    const config = {
      $schema:
        './node_modules/@stryker-mutator/core/schema/stryker-schema.json',
      _comment:
        'This config was generated by Ralph Loop. See https://stryker-mutator.io for more info.',
      packageManager: 'npm',
      testRunner: this.config.testRunner,
      coverageAnalysis: this.config.coverageAnalysis,
      mutate: [filePath],
      ...(testPattern && { testMatch: [testPattern] }),
      mutators: this.config.mutators,
      reporters: ['json', 'clear-text', 'progress'],
      timeoutMS: this.config.timeout,
    };

    await fs.writeFile('stryker.conf.json', JSON.stringify(config, null, 2));
  }

  /**
   * Parse Stryker JSON results
   */
  private async parseStrykerResults(): Promise<MutationResult> {
    try {
      const resultsPath = path.join('reports', 'mutation', 'mutation.json');
      const content = await fs.readFile(resultsPath, 'utf-8');
      const data = JSON.parse(content);

      const files = data.files || {};
      const mutations: Mutation[] = [];

      // Extract mutations from each file
      for (const [file, fileData] of Object.entries(files)) {
        const fileMutations = (fileData as any).mutants || [];

        for (const mutant of fileMutations) {
          mutations.push({
            id: mutant.id,
            mutatorName: mutant.mutatorName,
            location: {
              file,
              start: mutant.location.start,
              end: mutant.location.end,
            },
            replacement: mutant.replacement,
            status: mutant.status,
            killedBy: mutant.killedBy,
          });
        }
      }

      // Calculate statistics
      const killed = mutations.filter((m) => m.status === 'Killed').length;
      const survived = mutations.filter((m) => m.status === 'Survived').length;
      const timeout = mutations.filter((m) => m.status === 'Timeout').length;
      const noCoverage = mutations.filter(
        (m) => m.status === 'NoCoverage',
      ).length;
      const total = mutations.length;

      const mutationScore = total > 0 ? (killed / total) * 100 : 0;

      return {
        mutationScore,
        killed,
        survived,
        timeout,
        noCoverage,
        total,
        mutations,
      };
    } catch (error) {
      throw new Error(`Failed to parse Stryker results: ${error}`);
    }
  }

  /**
   * Get survived mutations (tests didn't catch these)
   */
  getSurvivedMutations(result: MutationResult): Mutation[] {
    return result.mutations.filter((m) => m.status === 'Survived');
  }

  /**
   * Analyze weak test coverage
   */
  analyzeWeakCoverage(result: MutationResult): {
    weakMutators: string[];
    uncoveredLines: Array<{ file: string; line: number }>;
    recommendations: string[];
  } {
    const survived = this.getSurvivedMutations(result);

    // Count by mutator
    const mutatorCounts = new Map<string, number>();
    for (const mutation of survived) {
      mutatorCounts.set(
        mutation.mutatorName,
        (mutatorCounts.get(mutation.mutatorName) || 0) + 1,
      );
    }

    // Sort by count
    const weakMutators = Array.from(mutatorCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([mutator]) => mutator);

    // Extract uncovered lines
    const uncoveredLines = survived.map((m) => ({
      file: m.location.file,
      line: m.location.start.line,
    }));

    // Generate recommendations
    const recommendations: string[] = [];

    if (result.mutationScore < 60) {
      recommendations.push(
        'CRITICAL: Mutation score below 60% - tests are not effective',
      );
    } else if (result.mutationScore < 80) {
      recommendations.push(
        'WARNING: Mutation score below 80% - improve test quality',
      );
    }

    if (survived.length > 10) {
      recommendations.push(
        `${survived.length} mutations survived - add tests for edge cases`,
      );
    }

    for (const mutator of weakMutators.slice(0, 3)) {
      recommendations.push(`Add tests to catch ${mutator} mutations`);
    }

    return {
      weakMutators,
      uncoveredLines,
      recommendations,
    };
  }

  /**
   * Generate test suggestions for survived mutations
   */
  generateTestSuggestions(result: MutationResult): string[] {
    const suggestions: string[] = [];
    const survived = this.getSurvivedMutations(result);

    for (const mutation of survived.slice(0, 5)) {
      const suggestion = this.getSuggestionForMutation(mutation);
      suggestions.push(suggestion);
    }

    return suggestions;
  }

  /**
   * Get test suggestion for specific mutation
   */
  private getSuggestionForMutation(mutation: Mutation): string {
    const mutatorSuggestions: Record<string, string> = {
      ArithmeticOperator:
        'Add test to verify arithmetic operations with different values',
      BooleanLiteral: 'Add test to verify both true and false branches',
      ConditionalExpression: 'Add test to verify all conditional branches',
      EqualityOperator: 'Add test to verify equality comparisons',
      LogicalOperator: 'Add test to verify logical AND/OR operations',
      StringLiteral: 'Add test to verify string value handling',
      UnaryOperator: 'Add test to verify negation and increment operations',
    };

    const baseSuggestion =
      mutatorSuggestions[mutation.mutatorName] ||
      `Add test for ${mutation.mutatorName}`;

    return `${baseSuggestion} at ${mutation.location.file}:${mutation.location.start.line}`;
  }

  /**
   * Check if mutation score meets threshold
   */
  meetsThreshold(result: MutationResult, threshold: number = 80): boolean {
    return result.mutationScore >= threshold;
  }

  /**
   * Format mutation report
   */
  formatReport(result: MutationResult): string {
    const lines: string[] = [];

    lines.push('='.repeat(60));
    lines.push('Mutation Testing Report');
    lines.push('='.repeat(60));
    lines.push('');

    lines.push(`Mutation Score: ${result.mutationScore.toFixed(1)}%`);
    lines.push('');

    lines.push('Summary:');
    lines.push(`  Total Mutations: ${result.total}`);
    lines.push(
      `  Killed: ${result.killed} (${((result.killed / result.total) * 100).toFixed(1)}%)`,
    );
    lines.push(
      `  Survived: ${result.survived} (${((result.survived / result.total) * 100).toFixed(1)}%)`,
    );
    lines.push(`  Timeout: ${result.timeout}`);
    lines.push(`  No Coverage: ${result.noCoverage}`);
    lines.push('');

    if (result.survived > 0) {
      lines.push('Survived Mutations:');
      const survived = this.getSurvivedMutations(result);

      for (const mutation of survived.slice(0, 10)) {
        lines.push(
          `  - ${mutation.mutatorName} at ${mutation.location.file}:${mutation.location.start.line}`,
        );
      }

      if (survived.length > 10) {
        lines.push(`  ... and ${survived.length - 10} more`);
      }

      lines.push('');
    }

    const analysis = this.analyzeWeakCoverage(result);

    if (analysis.recommendations.length > 0) {
      lines.push('Recommendations:');
      for (const rec of analysis.recommendations) {
        lines.push(`  - ${rec}`);
      }
    }

    return lines.join('\n');
  }
}
